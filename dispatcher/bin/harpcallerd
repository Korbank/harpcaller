#!/usr/bin/escript
%%! -env ERL_LIBS deps
%%----------------------------------------------------------------------------

-define(DEFAULT_CONFIG_FILE, "/etc/harpcaller/harpcaller.toml").
-define(DEFAULT_SOCKET_PATH, "/var/run/harpcaller/harpcaller.sock").

%% TODO: reload code
-record(cmd, {
  op :: start | wait_for_start | stop | reload_config |
        list_jobs | cancel_job |
        list_hosts | refresh_hosts |
        list_queues | list_queue | cancel_queue |
        dist_start | dist_stop,
  socket = ?DEFAULT_SOCKET_PATH :: file:filename(),
  options = [] :: [{Name :: string(), Value :: term()}],
  args    = [] :: [string()]
}).

%%----------------------------------------------------------------------------
%% help {{{

help() ->
  help(standard_io).

help(IO) ->
  Script = filename:basename(escript:script_name()),
  io:fwrite(IO, "HarpCaller daemon.~n", []),
  io:fwrite(IO, "Controlling daemon:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] start [--debug] [--config=...] [--pidfile=...]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] wait-for-start [--timeout=...]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] stop [--timeout=...] [--print-pid]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] reload-config~n", [Script]),
  io:fwrite(IO, "Jobs:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] cancel <job-id>~n", [Script]),
  io:fwrite(IO, "Hosts registry:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] hosts-list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] hosts-refresh~n", [Script]),
  io:fwrite(IO, "Job queues:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] queue-list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] queue-list <queue-name>~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] queue-cancel <queue-name>~n", [Script]),
  io:fwrite(IO, "Distributed Erlang support:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] dist-erl-start~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] dist-erl-stop~n", [Script]),
  ok.

%% }}}
%%----------------------------------------------------------------------------

main([])         -> help();
main(["-h"])     -> help();
main(["--help"]) -> help();

main(CmdLineArgs) ->
  case parse_options(CmdLineArgs) of
    {ok, Command} ->
      case cmd(Command) of
        ok ->
          ok;
        {error, Message} ->
          io:fwrite(standard_error, "~s~n", [Message]),
          halt(1)
      end;
    help ->
      help();
    {error, Message} ->
      io:fwrite(standard_error, "Error: ~s~n~n", [Message]),
      help(standard_error),
      halt(1)
  end.

%%----------------------------------------------------------------------------

%% @doc Execute command specified in command line.

-spec cmd(#cmd{}) ->
  ok | {error, iolist()}.

%% start the daemon
cmd(_Cmd = #cmd{op = start, socket = Socket, options = Options}) ->
  ConfigFile = proplists:get_value("config", Options, ?DEFAULT_CONFIG_FILE),
  case read_config(ConfigFile) of
    {ok, Config} ->
      case setup_harpcaller(Config) of
        ok ->
          case proplists:get_value("pidfile", Options) of
            undefined -> ok;
            PidFile -> indira:set_option(indira, pidfile, PidFile)
          end,
          case proplists:get_bool("debug", Options) of
            true -> indira:start_rec(sasl);
            false -> ok
          end,
          indira:set_option(indira, listen, [{indira_unix, Socket}]),
          indira:set_option(indira, command, {harpcaller_command_handler, []}),
          indira:start_rec(indira),
          indira:start_rec(harpcaller),
          indira:sleep_forever(),
          ok; % never reached
        {error, Message} ->
          {error, ["Configuration error: ", Message]}
      end;
    {error, Message} ->
      {error, ["Config reading error: ", Message]}
  end;

%% wait for daemon to start completely
cmd(_Cmd = #cmd{op = wait_for_start, socket = Socket, options = Options}) ->
  Timeout = proplists:get_value("timeout", Options, infinity),
  Command = harpcaller_command_handler:command_wait_for_start(),
  case indira:retry_send_one_command(indira_unix, Socket, Command, Timeout) of
    {ok, Reply} ->
      harpcaller_command_handler:reply_wait_for_start(Reply);
    {error, Reason} ->
      {error, format_send_error(Reason)}
  end;

%% stop the daemon
cmd(_Cmd = #cmd{op = stop, socket = Socket, options = Options}) ->
  Timeout = proplists:get_value("timeout", Options, infinity),
  Command = harpcaller_command_handler:command_stop(),
  case indira:send_one_command(indira_unix, Socket, Command, Timeout) of
    {ok, Reply} ->
      case proplists:get_bool("print-pid", Options) of
        true ->
          {ok, DaemonPID} = harpcaller_command_handler:reply_stop(Reply),
          io:fwrite("~s~n", [DaemonPID]);
        false ->
          ok
      end,
      ok;
    {error, closed} ->
      % this normally shouldn't happen, but just in case the daemon's Erlang
      % system shut down without allowing the reply to pass through, handle
      % this situation as well
      ok;
    {error, enoent} ->
      % daemon is not running, so let's consider it stopped
      ok;
    {error, Reason} ->
      {error, format_send_error(Reason)}
  end;

%% order the daemon to reload its config
cmd(_Cmd = #cmd{op = reload_config, socket = Socket}) ->
  send_command(
    Socket,
    harpcaller_command_handler:command_reload_config(),
    fun harpcaller_command_handler:reply_reload_config/1
  );

%% list RPC jobs the daemon currently runs
cmd(_Cmd = #cmd{op = list_jobs, socket = Socket}) ->
  Command = harpcaller_command_handler:command_list_jobs(),
  ResultFun = fun harpcaller_command_handler:reply_list_jobs/1,
  case send_command(Socket, Command, ResultFun) of
    {ok, Jobs} ->
      [io:fwrite("~s~n", [format_job_info(J)]) || J <- Jobs],
      ok;
    {error, Message} ->
      {error, Message}
  end;

%% cancel specific RPC job
cmd(_Cmd = #cmd{op = cancel_job, socket = Socket, args = [JobID]}) ->
  send_command(
    Socket,
    harpcaller_command_handler:command_cancel_job(JobID),
    fun harpcaller_command_handler:reply_cancel_job/1
  );

%% list hosts the daemon knows about
cmd(_Cmd = #cmd{op = list_hosts, socket = Socket}) ->
  Command = harpcaller_command_handler:command_list_hosts(),
  ResultFun = fun harpcaller_command_handler:reply_list_hosts/1,
  case send_command(Socket, Command, ResultFun) of
    {ok, Hosts} ->
      [io:fwrite("~s~n", [format_host_info(H)]) || H <- Hosts],
      ok;
    {error, Message} ->
      {error, Message}
  end;

%% order the daemon to refresh its known hosts registry
cmd(_Cmd = #cmd{op = refresh_hosts, socket = Socket}) ->
  send_command(
    Socket,
    harpcaller_command_handler:command_refresh_hosts(),
    fun harpcaller_command_handler:reply_refresh_hosts/1
  );

%% list job queues daemon currently has defined (non-empty)
cmd(_Cmd = #cmd{op = list_queues, socket = Socket}) ->
  Command = harpcaller_command_handler:command_list_queues(),
  ResultFun = fun harpcaller_command_handler:reply_list_queues/1,
  case send_command(Socket, Command, ResultFun) of
    {ok, Queues} ->
      [io:fwrite("~s~n", [format_queue_name(Q)]) || Q <- Queues],
      ok;
    {error, Message} ->
      {error, Message}
  end;

%% list specific job queue
cmd(_Cmd = #cmd{op = list_queue, socket = Socket, args = [Queue]}) ->
  % TODO: catch invalid queue format
  Command = harpcaller_command_handler:command_list_queue(Queue),
  ResultFun = fun harpcaller_command_handler:reply_list_queue/1,
  case send_command(Socket, Command, ResultFun) of
    {ok, Jobs} ->
      [io:fwrite("~s~n", [format_job_info(J)]) || J <- Jobs],
      ok;
    {error, Message} ->
      {error, Message}
  end;

%% clear all the jobs from specific queue
cmd(_Cmd = #cmd{op = cancel_queue, socket = Socket, args = [Queue]}) ->
  % TODO: catch invalid queue format
  send_command(
    Socket,
    harpcaller_command_handler:command_cancel_queue(Queue),
    fun harpcaller_command_handler:reply_cancel_queue/1
  );

%% order the daemon to setup its node for distributed Erlang environment
cmd(_Cmd = #cmd{op = dist_start, socket = Socket}) ->
  send_command(
    Socket,
    harpcaller_command_handler:command_dist_start(),
    fun harpcaller_command_handler:reply_dist_start/1
  );

%% order the daemon to tear down its distributed Erlang part
cmd(_Cmd = #cmd{op = dist_stop, socket = Socket}) ->
  send_command(
    Socket,
    harpcaller_command_handler:command_dist_stop(),
    fun harpcaller_command_handler:reply_dist_stop/1
  ).

%%----------------------------------------------------------
%% helpers {{{

-spec send_command(string(), indira_json:struct(), fun()) ->
  {ok, indira_json:struct()} | {error, iolist()}.

send_command(Socket, Command, ReplyParseFun) ->
  case indira:send_one_command(indira_unix, Socket, Command) of
    {ok, Reply} -> ReplyParseFun(Reply);
    {error, Reason} -> {error, format_send_error(Reason)}
  end.

-spec format_send_error(term()) ->
  iolist().

format_send_error(timeout = _Reason) -> "operation timed out";
format_send_error(Reason) -> inet:format_error(Reason).

%% }}}
%%----------------------------------------------------------

%%----------------------------------------------------------------------------
%% parse command line arguments {{{

%% @doc Parse command line arguments.

-spec parse_options([string()]) ->
  {ok, #cmd{}} | help | {error, string()}.

parse_options(Args) ->
  % escript can't into `fun store_arg/3' syntax
  Fun = fun(M,As,Acc) -> store_arg(M,As,Acc) end,
  case indira:args_foldg(Fun, #cmd{}, Args) of
    {ok, _Cmd = #cmd{op = undefined}} ->
      {error, "no command supplied"};
    {ok, _Cmd = #cmd{op = cancel_job, args = []}} ->
      {error, "no job specified"};
    {ok, _Cmd = #cmd{op = cancel_queue, args = []}} ->
      {error, "no queue specified"};
    {ok, Cmd = #cmd{}} ->
      {ok, Cmd};
    {error, {_Arg, help}} ->
      help;
    {error, {_Arg, Message}} ->
      {error, Message}
  end.

%% @doc Store an argument in `#cmd{}' structure.

-spec store_arg(SplitMark :: atom(), [string()], #cmd{}) ->
  #cmd{} | {error, help | iolist()}.

store_arg(single, ["--help" | _], _Cmd) ->
  {error, help};
store_arg(single, ["-h" | _], _Cmd) ->
  {error, help};

store_arg(single, ["--print-pid" | _], Cmd = #cmd{options = Options}) ->
  _NewCmd = Cmd#cmd{
    options = [{"print-pid", true} | Options]
  };

store_arg(single, ["--debug" | _], Cmd = #cmd{options = Options}) ->
  _NewCmd = Cmd#cmd{
    options = [{"debug", true} | Options]
  };

store_arg(_, ["--socket", Path | _], Cmd = #cmd{}) ->
  NewCmd = Cmd#cmd{socket = Path},
  {take, 2, NewCmd};

store_arg(_, ["--config", Path | _], Cmd = #cmd{options = Options}) ->
  NewCmd = Cmd#cmd{
    options = [{"config", Path} | Options]
  },
  {take, 2, NewCmd};

store_arg(_, ["--pidfile", Path | _], Cmd = #cmd{options = Options}) ->
  NewCmd = Cmd#cmd{
    options = [{"pidfile", Path} | Options]
  },
  {take, 2, NewCmd};

store_arg(_, ["--timeout", Timeout | _], Cmd = #cmd{options = Options})
when hd(Timeout) >= $1, hd(Timeout) =< $9 ->
  NewCmd = Cmd#cmd{
    % as an argument, it's specified as seconds, but we need milliseconds
    options = [{"timeout", 1000 * to_int(Timeout)} | Options]
  },
  {take, 2, NewCmd};
store_arg(_, ["--timeout", _Timeout | _], _Cmd) ->
  {error, "invalid timeout"};

store_arg(_, ["--" ++ _ = Option | _], _Cmd) ->
  {error, ["unknown option: ", Option]};

store_arg(_, ["start" | _],          Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = start};
store_arg(_, ["wait-for-start" | _], Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = wait_for_start};
store_arg(_, ["stop" | _],           Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = stop};
store_arg(_, ["reload-config" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = reload_config};

store_arg(_, ["list" | _],           Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_jobs};
store_arg(_, ["cancel" | _],         Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = cancel_job};

store_arg(_, ["hosts-list" | _],     Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_hosts};
store_arg(_, ["hosts-refresh" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = refresh_hosts};

store_arg(_, ["queue-list" | _],     Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_queues};
store_arg(_, ["queue-cancel" | _],   Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = cancel_queue};

store_arg(_, ["dist-erl-start" | _], Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = dist_start};
store_arg(_, ["dist-erl-stop" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = dist_stop};

store_arg(_, [JobID | _], Cmd = #cmd{op = cancel_job, args = []}) ->
  _NewCmd = Cmd#cmd{args = [JobID]};
store_arg(_, [Queue | _], Cmd = #cmd{op = list_queues, args = []}) ->
  case indira_json:decode(Queue) of
    {ok, QueueStruct} -> Cmd#cmd{op = list_queue, args = [QueueStruct]};
    {error, badarg} -> {error, "invalid queue name format"}
  end;
store_arg(_, [Queue | _], Cmd = #cmd{op = cancel_queue, args = []}) ->
  case indira_json:decode(Queue) of
    {ok, QueueStruct} -> Cmd#cmd{args = [QueueStruct]};
    {error, badarg} -> {error, "invalid queue name format"}
  end;

store_arg(_, [Command | _], _Cmd = #cmd{op = undefined}) ->
  {error, ["unknown command: ", Command]};
store_arg(_, [_ | _], _Cmd = #cmd{}) ->
  {error, "too many arguments for this command"}.

%% }}}
%%----------------------------------------------------------------------------
%% configure HarpCaller daemon {{{

%% @doc Setup `harpcaller' Erlang application with values from config file.

-spec setup_harpcaller([{binary(), term()}]) ->
  ok | {error, iolist()}.

setup_harpcaller(Config) ->
  ok = indira:set_option(harpcaller, listen, []),
  SetSpecs = [
    {<<"listen">>,          {harpcaller, listen}},
    {<<"stream_directory">>,{harpcaller, stream_directory}},
    {<<"default_timeout">>, {harpcaller, default_timeout}},
    {<<"max_exec_time">>,   {harpcaller, max_exec_time}},
    {<<"host_db_script">>,  {harpcaller, host_db_script}},
    {<<"ca_file">>,         {harpcaller, ca_file}},
    {<<"known_certs_file">>,{harpcaller, known_certs_file}},
    {<<"host_db">>,         {harpcaller, host_db}},
    {<<"host_db_refresh">>, {harpcaller, host_db_refresh}},
    {<<"log_handlers">>,    {harpcaller, log_handlers}}
  ],
  Result = indira:set_env(
    fun proplists:get_value/2,
    fun (K,EK,V) -> cfg(K,EK,V) end,
    Config,
    SetSpecs
  ),
  case Result of
    ok ->
      setup_erlang(Config);
    {error, {Key, _EnvKey, invalid_option_format}} ->
      {error, ["option ", Key, ": invalid format"]};
    {error, {Key, _EnvKey, no_listeners}} ->
      {error, ["option ", Key, ": no listeners defined"]}
  end.

%% @doc Setup Erlang configuration.
%%   This covers distributed Erlang and system events sent through
%%   {@link error_logger}.

-spec setup_erlang([{binary(), term()}]) ->
  ok | {error, iolist()}.

setup_erlang(TopConfig) ->
  Config = proplists:get_value(<<"erlang">>, TopConfig, []),
  NetConfig = [
    proplists:get_value(K, Config) ||
    K <- [<<"node_name">>, <<"name_type">>, <<"cookie_file">>]
  ],
  NetStart = proplists:get_value(<<"distributed_immediate">>, Config, false),
  LogHandlers = proplists:get_value(<<"error_logger_handlers">>, Config, []),
  case NetConfig of
    [Name, <<"shortnames">>, File] when is_binary(Name), is_binary(File) ->
      indira:distributed(binary_to_atom(Name, utf8), shortnames, {file, File});
    [Name, <<"longnames">>, File] when is_binary(Name), is_binary(File) ->
      indira:distributed(binary_to_atom(Name, utf8), longnames, {file, File});
    [Name, <<"shortnames">>, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8), shortnames);
    [Name, <<"longnames">>, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8), longnames);
    [Name, undefined, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8));
    _ ->
      skip
  end,
  indira:set_option(indira, net_start, NetStart),
  indira:setup_logging(harpcaller, []), % clear default log handlers
  try
    [error_logger:add_report_handler(binary_to_atom(H, utf8)) ||
      H <- LogHandlers],
    ok
  catch
    error:{bad_generator, _} ->
      % `erlang.error_logger_handlers' is not a list
      {error, "option erlang.error_logger_handlers: not a list"};
    error:badarg ->
      % one of the elements in `erlang.error_logger_handlers' is not a string
      {error, "option erlang.error_logger_handlers: invalid format"}
  end.

%% }}}
%%----------------------------------------------------------------------------
%% config validation {{{

%% @doc Option validator function.

cfg(_Key, _EnvKey, undefined = _Value) ->
  ignore;

cfg(<<"listen">> = _Key, _EnvKey, Specs) when is_list(Specs) ->
  try [parse_listen_spec(S) || S <- Specs] of
    [] -> {error, no_listeners};
    [_ | _] = Result -> {ok, Result}
  catch
    error:_ -> {error, invalid_option_format}
  end;

cfg(<<"stream_directory">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"default_timeout">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"max_exec_time">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"ca_file">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"known_certs_file">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"host_db_script">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"host_db">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"host_db_refresh">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"log_handlers">> = _Key, _EnvKey, Handlers) when is_list(Handlers) ->
  try
    {ok, [{binary_to_atom(H, utf8), []} || H <- Handlers]}
  catch
    error:_ -> {error, invalid_option_format}
  end;

cfg(_Key, _EnvKey, _Value) ->
  {error, invalid_option_format}.

%%----------------------------------------------------------
%% parsing helpers {{{

%% @doc Convert listening address specification from config file to format
%%   suitable for application environment.

-spec parse_listen_spec(binary()) ->
  {any | inet:hostname(), inet:port_number()}.

parse_listen_spec(Spec) when is_binary(Spec) ->
  % die when the listen specification doesn't match what we expect
  case binary:split(Spec, <<":">>) of
    [<<"*">>, PortBin] -> {any, to_int(PortBin)};
    [AddrBin, PortBin] -> {binary_to_list(AddrBin), to_int(PortBin)}
  end.

%% }}}
%%----------------------------------------------------------

%% }}}
%%----------------------------------------------------------------------------
%% parsing config file {{{

%% @doc Read TOML configuration file.

-spec read_config(file:filename()) ->
  {ok, [{binary(), term()}]} | {error, iolist()}.

read_config(ConfigFile) ->
  case file:read_file(ConfigFile) of
    {ok, ConfigContent} ->
      case etoml:parse(ConfigContent) of
        {ok, Config} ->
          {ok, Config};
        {error, Reason} ->
          {error, ["parsing error: ", format_toml_error(Reason)]}
      end;
    {error, Reason} ->
      {error, ["reading error: ", format_read_error(Reason)]}
  end.

%% @doc Format TOML parsing error.

-spec format_toml_error(term()) ->
  iolist().

format_toml_error({invalid_key, Line} = _Reason) ->
  io_lib:format("line ~B: invalid key name", [Line]);
format_toml_error({invalid_group, Line} = _Reason) ->
  io_lib:format("line ~B: invalid group name", [Line]);
format_toml_error({invalid_date, Line} = _Reason) ->
  io_lib:format("line ~B: invalid date format", [Line]);
format_toml_error({invalid_number, Line} = _Reason) ->
  io_lib:format("line ~B: invalid number value or forgotten quotes", [Line]);
format_toml_error({invalid_array, Line} = _Reason) ->
  io_lib:format("line ~B: invalid array format", [Line]);
format_toml_error({invalid_string, Line} = _Reason) ->
  io_lib:format("line ~B: invalid string format", [Line]);
format_toml_error({undefined_value, Line} = _Reason) ->
  io_lib:format("line ~B: value not provided", [Line]);
format_toml_error({duplicated_key, Key}  = _Reason) ->
  io_lib:format("duplicated key: ~s", [Key]).

%% @doc Format file reading error.

-spec format_read_error(term()) ->
  string().

format_read_error(Reason) ->
  file:format_error(Reason).

%% }}}
%%----------------------------------------------------------------------------

%%----------------------------------------------------------
%% helpers {{{

format_job_info(JobInfo) ->
  {ok, JSON} = indira_json:encode(JobInfo),
  JSON.

format_host_info(HostInfo) ->
  {ok, JSON} = indira_json:encode(HostInfo),
  JSON.

format_queue_name(QueueName) ->
  {ok, JSON} = indira_json:encode(QueueName),
  JSON.

%% @doc Convert string representation of an integer to integer itself.
%%   Only accepts positive integers.

-spec to_int(binary() | string()) ->
  pos_integer().

to_int(String) when is_binary(String) ->
  to_int(binary_to_list(String));
to_int([C | _] = String) when C >= $1, C =< $9 ->
  list_to_integer(String).

%% }}}
%%----------------------------------------------------------

%%----------------------------------------------------------------------------
%% vim:ft=erlang:foldmethod=marker
