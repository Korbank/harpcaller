#!/usr/bin/escript
%%! -env ERL_LIBS deps
%%----------------------------------------------------------------------------

-define(DEFAULT_CONFIG_FILE, "/etc/korrpcdid/korrpcdid.toml").
-define(DEFAULT_SOCKET_PATH, "/var/run/korrpcdid/korrpcdid.sock").

%% TODO: reload code
%% TODO: debug load (`application:start(sasl)')
-record(cmd, {
  op :: start | wait_for_start | stop | reload_config |
        list_jobs | cancel_job |
        list_hosts | refresh_hosts |
        list_queues | list_queue | cancel_queue |
        dist_start | dist_stop,
  socket = ?DEFAULT_SOCKET_PATH :: file:filename(),
  options = [] :: [{Name :: string(), Value :: term()}],
  args    = [] :: [string()]
}).

%%----------------------------------------------------------------------------
%% help {{{

help() ->
  help(standard_io).

help(IO) ->
  Script = filename:basename(escript:script_name()),
  io:fwrite(IO, "KorRPC dispatcher daemon.~n", []),
  io:fwrite(IO, "Controlling daemon:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] start [--config=...] [--pidfile=...]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] wait-for-start [--timeout=...]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] stop [--timeout=...]~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] reload-config~n", [Script]),
  io:fwrite(IO, "Jobs:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] cancel <job-id>~n", [Script]),
  io:fwrite(IO, "Hosts registry:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] hosts-list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] hosts-refresh~n", [Script]),
  io:fwrite(IO, "Job queues:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] queue-list~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] queue-list <queue-name>~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] queue-cancel <queue-name>~n", [Script]),
  io:fwrite(IO, "Distributed Erlang support:~n", []),
  io:fwrite(IO, "  ~s [--socket=...] dist-erl-start~n", [Script]),
  io:fwrite(IO, "  ~s [--socket=...] dist-erl-stop~n", [Script]),
  ok.

%% }}}
%%----------------------------------------------------------------------------

main([])         -> help();
main(["-h"])     -> help();
main(["--help"]) -> help();

main(CmdLineArgs) ->
  case parse_options(CmdLineArgs) of
    {ok, Command} ->
      case cmd(Command) of
        ok ->
          ok;
        {error, Message} ->
          io:fwrite(standard_error, "~s~n", [Message]),
          halt(1)
      end;
    help ->
      help();
    {error, Message} ->
      io:fwrite(standard_error, "Error: ~s~n~n", [Message]),
      help(standard_error),
      halt(1)
  end.

%%----------------------------------------------------------------------------

%% @doc Execute command specified in command line.

-spec cmd(#cmd{}) ->
  ok | {error, iolist()}.

%% start the daemon
cmd(_Cmd = #cmd{op = start, socket = Socket, options = Options}) ->
  ConfigFile = proplists:get_value("config", Options, ?DEFAULT_CONFIG_FILE),
  case read_config(ConfigFile) of
    {ok, Config} ->
      case setup_korrpcdid(Config) of
        ok ->
          case proplists:get_value("pidfile", Options) of
            undefined -> ok;
            PidFile -> indira:set_option(indira, pidfile, PidFile)
          end,
          indira:set_option(indira, listen, [{indira_unix, Socket}]),
          indira:set_option(indira, command, {korrpcdid_command_handler, []}),
          indira:start_rec(indira),
          indira:start_rec(korrpcdid),
          indira:sleep_forever(),
          ok; % never reached
        {error, Message} ->
          {error, ["Configuration error: ", Message]}
      end;
    {error, Message} ->
      {error, ["Config reading error: ", Message]}
  end;

%% wait for daemon to start completely
cmd(_Cmd = #cmd{op = wait_for_start, socket = Socket, options = Options}) ->
  Timeout = proplists:get_value("timeout", Options, infinity),
  case retry_send_command(Socket, wait_for_start, Timeout) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% stop the daemon
cmd(_Cmd = #cmd{op = stop, socket = Socket, options = Options}) ->
  Timeout = proplists:get_value("timeout", Options, infinity),
  case send_command(Socket, stop, Timeout) of
    {ok, [{<<"pid">>, DaemonPID}, {<<"result">>, <<"ok">>}] = _Reply} ->
      % reply to `stop' command got through before the Erlang system shut
      % down; print the daemon's PID and let the caller wait for it to
      % disappear
      % TODO: only print PID on request
      io:fwrite("~s~n", [DaemonPID]),
      ok;
    {error, closed} ->
      % this should never happen, but just in case the daemon's Erlang system
      % shut down without allowing the reply to pass through, handle this
      % situation as well
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% order the daemon to reload its config
cmd(_Cmd = #cmd{op = reload_config, socket = Socket}) ->
  case send_command(Socket, reload_config) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% list RPC jobs the daemon currently runs
cmd(_Cmd = #cmd{op = list_jobs, socket = Socket}) ->
  case send_command(Socket, list_jobs) of
    {ok, Reply} ->
      io:fwrite("# jobs:~n"),
      io:fwrite("% ~1024p~n", [Reply]),
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% cancel specific RPC job
cmd(_Cmd = #cmd{op = cancel_job, socket = Socket, args = [JobID]}) ->
  case send_command(Socket, {cancel_job, job, JobID}) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% list hosts the daemon knows about
cmd(_Cmd = #cmd{op = list_hosts, socket = Socket}) ->
  case send_command(Socket, list_hosts) of
    {ok, Reply} ->
      io:fwrite("# hosts:~n"),
      io:fwrite("% ~1024p~n", [Reply]),
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% order the daemon to refresh its known hosts registry
cmd(_Cmd = #cmd{op = refresh_hosts, socket = Socket}) ->
  case send_command(Socket, refresh_hosts) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% list job queues daemon currently has defined (non-empty)
cmd(_Cmd = #cmd{op = list_queues, socket = Socket}) ->
  case send_command(Socket, list_queues) of
    {ok, Reply} ->
      io:fwrite("# queues:~n"),
      io:fwrite("% ~1024p~n", [Reply]),
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% list specific job queue
cmd(_Cmd = #cmd{op = list_queue, socket = Socket, args = [Queue]}) ->
  case send_command(Socket, {list_queue, 'queue', Queue}) of
    {ok, Reply} ->
      io:fwrite("# queue ~s:~n", [Queue]),
      io:fwrite("% ~1024p~n", [Reply]),
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% clear all the jobs from specific queue
cmd(_Cmd = #cmd{op = cancel_queue, socket = Socket, args = [Queue]}) ->
  case send_command(Socket, {cancel_queue, 'queue', Queue}) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% order the daemon to setup its node for distributed Erlang environment
cmd(_Cmd = #cmd{op = dist_start, socket = Socket}) ->
  case send_command(Socket, dist_start) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end;

%% order the daemon to tear down its distributed Erlang part
cmd(_Cmd = #cmd{op = dist_stop, socket = Socket}) ->
  case send_command(Socket, dist_stop) of
    {ok, _Reply} ->
      ok;
    {error, Reason} ->
      Message = io_lib:format("communication error: ~1024p", [Reason]),
      {error, Message}
  end.

%%----------------------------------------------------------------------------
%% control socket commands {{{

%% @doc Send a command through specified socket to a running daemon.
%%
%%   `Command' is a term suitable for {@link encode_command/1}.
%%
%%   Function waits infinitely for a response.

-spec send_command(file:filename(), term()) ->
  {ok, term()} | {error, term()}.

send_command(Socket, Command) ->
  send_command(Socket, Command, infinity).

%% @doc Send a command through specified socket to a running daemon.
%%
%%   `Command' is a term suitable for {@link encode_command/1}.
%%
%%   Function waits `Timeout' seconds for a response.

-spec send_command(file:filename(), term(), timeout()) ->
  {ok, term()} | {error, term()}.

send_command(Socket, Command, Timeout) ->
  Line = encode_command(Command),
  case connect_send_recv_line(Socket, Line, seconds_to_milliseconds(Timeout)) of
    {ok, ReplyLine} ->
      Reply = decode_command_reply(ReplyLine),
      {ok, Reply};
    {error, Reason} ->
      {error, Reason} % TODO: format `Reason'
  end.

%% @doc Send a command through specified socket to a running daemon, retrying
%%   if the socket doesn't exist yet.
%%
%%   `Command' is a term suitable for {@link encode_command/1}.
%%
%%   Function waits `Timeout' seconds for the socket to appear, and then
%%   another `Timeout' seconds for a response.

-spec retry_send_command(file:filename(), term(), timeout()) ->
  {ok, term()} | {error, term()}.

retry_send_command(Socket, Command, Timeout) ->
  TimeoutRef = make_ref(),
  case Timeout of
    _ when is_integer(Timeout) ->
      % don't need to remember this timer, as it's just one of them, and the
      % Erlang machine will halt
      _Ref = erlang:send_after(Timeout * 1000, self(), {timeout, TimeoutRef});
    infinity ->
      ok
  end,
  retry_send_command(Socket, Command, Timeout, TimeoutRef).

%% @doc Worker for {@link retry_send_command/3}.

-spec retry_send_command(file:filename(), term(), timeout(), reference()) ->
  {ok, term()} | {error, term()}.

retry_send_command(Socket, Command, Timeout, TimeoutRef) ->
  % try connecting to the socket
  % if it succeeds, excellent
  % if it fails because the socket doesn't exist (yet), try after 100ms (watch
  % for requested timeout)
  % if it fails for any reason other than the socket doesn't exist (yet), it's
  % a permanent failure
  case send_command(Socket, Command, Timeout) of
    {ok, Reply} ->
      {ok, Reply};
    {error, enoent} ->
      receive
        {timeout, TimeoutRef} ->
          {error, timeout}
      after 100 ->
          retry_send_command(Socket, Command, Timeout, TimeoutRef)
      end;
    {error, Reason} ->
      {error, Reason}
  end.

%% @doc Connect to specified socket, send a line, read a line, and close
%%   socket.
%%
%%   Waits `Timeout' milliseconds for a response.

-spec connect_send_recv_line(file:filename(), iolist(), timeout()) ->
  {ok, binary()} | {error, term()}.

connect_send_recv_line(SocketPath, Line, Timeout) ->
  case indira_af_unix:connect(SocketPath, [{active, false}]) of
    {ok, Socket} ->
      ok = indira_af_unix:send(Socket, [Line, $\n]),
      RecvResult = indira_af_unix:recv(Socket, 0, Timeout),
      ok = indira_af_unix:close(Socket),
      RecvResult;
    {error, Reason} ->
      {error, Reason}
  end.

%% @doc Encode command as a JSON line.

-spec encode_command(atom() |
                     {Cmd :: atom(), ArgName :: atom() | string() | binary(),
                      ArgValue :: atom() | string() | binary()}) ->
  iolist().

encode_command(Command) when is_atom(Command) ->
  {ok, Line} = korrpc_json:encode([{command, Command}]),
  Line;
encode_command({C, ArgName, ArgValue} = _Command) when is_list(ArgName) ->
  encode_command({C, list_to_binary(ArgName), ArgValue});
encode_command({C, ArgName, ArgValue} = _Command) when is_list(ArgValue) ->
  encode_command({C, ArgName, list_to_binary(ArgValue)});
encode_command({C, ArgName, ArgValue} = _Command) ->
  {ok, Line} = korrpc_json:encode([{command, C}, {ArgName, ArgValue}]),
  Line.

%% @doc Decode response to an earlier sent command to jsx-like structure.

-spec decode_command_reply(string() | binary()) ->
  term().

decode_command_reply(ReplyLine) ->
  {ok, Reply} = korrpc_json:decode(ReplyLine), % Indira won't fail us here
  Reply.

%% @doc Convert timeout specified in seconds to a timeout in milliseconds.

-spec seconds_to_milliseconds(timeout()) ->
  timeout().

seconds_to_milliseconds(infinity = _Timeout) ->
  infinity;
seconds_to_milliseconds(Timeout) when is_integer(Timeout) ->
  Timeout * 1000.

%% }}}
%%----------------------------------------------------------------------------
%% parse command line arguments {{{

%% @doc Parse command line arguments.

-spec parse_options([string()]) ->
  {ok, #cmd{}} | help | {error, string()}.

parse_options(Args) ->
  % escript can't into `fun store_arg/3' syntax
  Fun = fun(M,As,Acc) -> store_arg(M,As,Acc) end,
  case indira:args_foldg(Fun, #cmd{}, Args) of
    {ok, _Cmd = #cmd{op = undefined}} ->
      {error, "no command supplied"};
    {ok, _Cmd = #cmd{op = cancel_job, args = []}} ->
      {error, "no job specified"};
    {ok, _Cmd = #cmd{op = cancel_queue, args = []}} ->
      {error, "no queue specified"};
    {ok, Cmd = #cmd{}} ->
      {ok, Cmd};
    {error, {_Arg, help}} ->
      help;
    {error, {_Arg, Message}} ->
      {error, Message}
  end.

%% @doc Store an argument in `#cmd{}' structure.

-spec store_arg(SplitMark :: atom(), [string()], #cmd{}) ->
  #cmd{} | {error, help | iolist()}.

store_arg(single, ["--help" | _], _Cmd) ->
  {error, help};
store_arg(single, ["-h" | _], _Cmd) ->
  {error, help};

store_arg(_, ["--socket", Path | _], Cmd = #cmd{}) ->
  NewCmd = Cmd#cmd{socket = Path},
  {take, 2, NewCmd};

store_arg(_, ["--config", Path | _], Cmd = #cmd{options = Options}) ->
  NewCmd = Cmd#cmd{
    options = [{"config", Path} | Options]
  },
  {take, 2, NewCmd};

store_arg(_, ["--pidfile", Path | _], Cmd = #cmd{options = Options}) ->
  NewCmd = Cmd#cmd{
    options = [{"pidfile", Path} | Options]
  },
  {take, 2, NewCmd};

store_arg(_, ["--timeout", Timeout | _], Cmd = #cmd{options = Options})
when hd(Timeout) >= $1, hd(Timeout) =< $9 ->
  NewCmd = Cmd#cmd{
    options = [{"timeout", to_int(Timeout)} | Options]
  },
  {take, 2, NewCmd};
store_arg(_, ["--timeout", _Timeout | _], _Cmd) ->
  {error, "invalid timeout"};

store_arg(_, ["--" ++ _ = Option | _], _Cmd) ->
  {error, ["unknown option: ", Option]};

store_arg(_, ["start" | _],          Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = start};
store_arg(_, ["wait-for-start" | _], Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = wait_for_start};
store_arg(_, ["stop" | _],           Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = stop};
store_arg(_, ["reload-config" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = reload_config};

store_arg(_, ["list" | _],           Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_jobs};
store_arg(_, ["cancel" | _],         Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = cancel_job};

store_arg(_, ["hosts-list" | _],     Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_hosts};
store_arg(_, ["hosts-refresh" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = refresh_hosts};

store_arg(_, ["queue-list" | _],     Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = list_queue};
store_arg(_, ["queue-cancel" | _],   Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = cancel_queue};

store_arg(_, ["dist-erl-start" | _], Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = dist_start};
store_arg(_, ["dist-erl-stop" | _],  Cmd = #cmd{op = undefined}) ->
  _NewCmd = Cmd#cmd{op = dist_stop};

store_arg(_, [JobID | _], Cmd = #cmd{op = cancel_job, args = []}) ->
  _NewCmd = Cmd#cmd{args = [JobID]};
store_arg(_, [Queue | _], Cmd = #cmd{op = list_queue, args = []}) ->
  _NewCmd = Cmd#cmd{op = list_queues, args = [Queue]};
store_arg(_, [Queue | _], Cmd = #cmd{op = cancel_queue, args = []}) ->
  _NewCmd = Cmd#cmd{args = [Queue]};

store_arg(_, [Command | _], _Cmd = #cmd{op = undefined}) ->
  {error, ["unknown command: ", Command]};
store_arg(_, [_ | _], _Cmd = #cmd{}) ->
  {error, "too many arguments for this command"}.

%% }}}
%%----------------------------------------------------------------------------
%% configure KorRPC dispatcher daemon {{{

%% @doc Setup `korrpcdid' Erlang application with values from config file.

-spec setup_korrpcdid([{binary(), term()}]) ->
  ok | {error, iolist()}.

setup_korrpcdid(Config) ->
  ok = indira:set_option(korrpcdid, listen, []),
  SetSpecs = [
    {<<"listen">>,          {korrpcdid, listen}},
    {<<"stream_directory">>,{korrpcdid, stream_directory}},
    {<<"default_timeout">>, {korrpcdid, default_timeout}},
    {<<"max_exec_time">>,   {korrpcdid, max_exec_time}},
    {<<"host_db_script">>,  {korrpcdid, host_db_script}},
    {<<"host_db">>,         {korrpcdid, host_db}},
    {<<"host_db_refresh">>, {korrpcdid, host_db_refresh}},
    {<<"log_handlers">>,    {korrpcdid, log_handlers}}
  ],
  Result = indira:set_env(
    fun proplists:get_value/2,
    fun (K,EK,V) -> cfg(K,EK,V) end,
    Config,
    SetSpecs
  ),
  case Result of
    ok ->
      setup_erlang(Config);
    {error, {Key, _EnvKey, invalid_option_format}} ->
      {error, ["option ", Key, ": invalid format"]};
    {error, {Key, _EnvKey, no_listeners}} ->
      {error, ["option ", Key, ": no listeners defined"]}
  end.

%% @doc Setup Erlang configuration.
%%   This covers distributed Erlang and system events sent through
%%   {@link error_logger}.

-spec setup_erlang([{binary(), term()}]) ->
  ok | {error, iolist()}.

setup_erlang(TopConfig) ->
  Config = proplists:get_value(<<"erlang">>, TopConfig, []),
  NetConfig = [
    proplists:get_value(K, Config) ||
    K <- [<<"node_name">>, <<"name_type">>, <<"cookie_file">>]
  ],
  NetStart = proplists:get_value(<<"distributed_immediate">>, Config, false),
  LogHandlers = proplists:get_value(<<"error_logger_handlers">>, Config, []),
  case NetConfig of
    [Name, <<"shortnames">>, File] when is_binary(Name), is_binary(File) ->
      indira:distributed(binary_to_atom(Name, utf8), shortnames, {file, File});
    [Name, <<"longnames">>, File] when is_binary(Name), is_binary(File) ->
      indira:distributed(binary_to_atom(Name, utf8), longnames, {file, File});
    [Name, <<"shortnames">>, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8), shortnames);
    [Name, <<"longnames">>, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8), longnames);
    [Name, undefined, undefined] when is_binary(Name) ->
      indira:distributed(binary_to_atom(Name, utf8));
    _ ->
      skip
  end,
  indira:set_option(indira, net_start, NetStart),
  indira:setup_logging(korrpcdid, []), % clear default log handlers
  try
    [error_logger:add_report_handler(binary_to_atom(H, utf8)) ||
      H <- LogHandlers],
    ok
  catch
    error:{bad_generator, _} ->
      % `erlang.error_logger_handlers' is not a list
      {error, "option erlang.error_logger_handlers: not a list"};
    error:badarg ->
      % one of the elements in `erlang.error_logger_handlers' is not a string
      {error, "option erlang.error_logger_handlers: invalid format"}
  end.

%% }}}
%%----------------------------------------------------------------------------
%% config validation {{{

%% @doc Option validator function.

cfg(_Key, _EnvKey, undefined = _Value) ->
  ignore;

cfg(<<"listen">> = _Key, _EnvKey, Specs) when is_list(Specs) ->
  try [parse_listen_spec(S) || S <- Specs] of
    [] -> {error, no_listeners};
    [_ | _] = Result -> {ok, Result}
  catch
    error:_ -> {error, invalid_option_format}
  end;

cfg(<<"stream_directory">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"default_timeout">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"max_exec_time">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"host_db_script">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"host_db">> = _Key, _EnvKey, Path) when is_binary(Path) ->
  {ok, binary_to_list(Path)};

cfg(<<"host_db_refresh">> = _Key, _EnvKey, T) when is_integer(T), T > 0 ->
  ok;

cfg(<<"log_handlers">> = _Key, _EnvKey, Handlers) when is_list(Handlers) ->
  try
    {ok, [{binary_to_atom(H, utf8), []} || H <- Handlers]}
  catch
    error:_ -> {error, invalid_option_format}
  end;

cfg(_Key, _EnvKey, _Value) ->
  {error, invalid_option_format}.

%%----------------------------------------------------------
%% parsing helpers {{{

%% @doc Convert listening address specification from config file to format
%%   suitable for application environment.

-spec parse_listen_spec(binary()) ->
  {any | inet:hostname(), inet:port_number()}.

parse_listen_spec(Spec) when is_binary(Spec) ->
  % die when the listen specification doesn't match what we expect
  case binary:split(Spec, <<":">>) of
    [<<"*">>, PortBin] -> {any, to_int(PortBin)};
    [AddrBin, PortBin] -> {binary_to_list(AddrBin), to_int(PortBin)}
  end.

%% }}}
%%----------------------------------------------------------

%% }}}
%%----------------------------------------------------------------------------
%% parsing config file {{{

%% @doc Read TOML configuration file.

-spec read_config(file:filename()) ->
  {ok, [{binary(), term()}]} | {error, iolist()}.

read_config(ConfigFile) ->
  case file:read_file(ConfigFile) of
    {ok, ConfigContent} ->
      case etoml:parse(ConfigContent) of
        {ok, Config} ->
          {ok, Config};
        {error, Reason} ->
          {error, ["parsing error: ", format_toml_error(Reason)]}
      end;
    {error, Reason} ->
      {error, ["reading error: ", format_read_error(Reason)]}
  end.

%% @doc Format TOML parsing error.

-spec format_toml_error(term()) ->
  iolist().

format_toml_error({invalid_key, Line} = _Reason) ->
  io_lib:format("line ~B: invalid key name", [Line]);
format_toml_error({invalid_group, Line} = _Reason) ->
  io_lib:format("line ~B: invalid group name", [Line]);
format_toml_error({invalid_date, Line} = _Reason) ->
  io_lib:format("line ~B: invalid date format", [Line]);
format_toml_error({invalid_number, Line} = _Reason) ->
  io_lib:format("line ~B: invalid number value or forgotten quotes", [Line]);
format_toml_error({invalid_array, Line} = _Reason) ->
  io_lib:format("line ~B: invalid array format", [Line]);
format_toml_error({invalid_string, Line} = _Reason) ->
  io_lib:format("line ~B: invalid string format", [Line]);
format_toml_error({undefined_value, Line} = _Reason) ->
  io_lib:format("line ~B: value not provided", [Line]);
format_toml_error({duplicated_key, Key}  = _Reason) ->
  io_lib:format("duplicated key: ~s", [Key]).

%% @doc Format file reading error.

-spec format_read_error(term()) ->
  string().

format_read_error(Reason) ->
  file:format_error(Reason).

%% }}}
%%----------------------------------------------------------------------------

%%----------------------------------------------------------
%% helpers {{{

%% @doc Convert string representation of an integer to integer itself.
%%   Only accepts positive integers.

-spec to_int(binary() | string()) ->
  pos_integer().

to_int(String) when is_binary(String) ->
  to_int(binary_to_list(String));
to_int([C | _] = String) when C >= $1, C =< $9 ->
  list_to_integer(String).

%% }}}
%%----------------------------------------------------------

%%----------------------------------------------------------------------------
%% vim:ft=erlang:foldmethod=marker
